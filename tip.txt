 /*`c_str()` 返回一个以 null 结尾的 C 风格字符串指针，保证数据不可修改。
            `data()` 返回一个指向字符串数据的指针，允许修改，但不保证以 null 结尾。*/
#include<sys/eventfd.h>
{
    `eventfd` 是一个 Linux 特有的系统调用，用于创建一个事件文件描述符 (Eventfd)。它提供了一种简单的方法来实现进程间的同步和通信。

通常情况下，`eventfd` 函数的原型如下：

```c
#include <sys/eventfd.h>
int eventfd(unsigned int initval, int flags);
```

参数说明：
- `initval`：是一个无符号整数，用于初始化事件计数器的值。
- `flags`：可以是以下标志的按位或组合：
  - `EFD_SEMAPHORE`：使用信号量语义而不是计数器语义。这个标志会影响事件计数器的行为，使得它表现得像一个信号量。每次写入时，事件计数器的值都会递增，每次读取时，事件计数器的值会递减，直到它变为零。
  - `EFD_CLOEXEC`：设置 close-on-exec 标志，这意味着在 `exec` 被调用时，事件描述符会被关闭。
  - `EFD_NONBLOCK`：设置为非阻塞模式，这样 `read` 或 `write` 操作不会阻塞。

`eventfd` 函数创建一个新的 eventfd 文件描述符，用于进程间通信。你可以使用 `read` 和 `write` 函数来读取和写入该描述符，以实现通信。通常，一个进程使用 `write` 来增加计数器的值，另一个进程则使用 `read` 来读取该值。

示例代码如下：

```c
#include <sys/eventfd.h>
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>

int main() {
    int m_wakeup_fd = eventfd(0, EFD_NONBLOCK);
    if (m_wakeup_fd == -1) {
        perror("eventfd");
        return 1;
    }

    // 写入事件
    uint64_t value = 1;
    if (write(m_wakeup_fd, &value, sizeof(value)) == -1) {
        perror("write");
        return 1;
    }

    // 读取事件
    uint64_t read_value;
    if (read(m_wakeup_fd, &read_value, sizeof(read_value)) == -1) {
        perror("read");
        return 1;
    }

    printf("Read value: %lu\n", (unsigned long)read_value);

    close(m_wakeup_fd);

    return 0;
}
```

在这个示例中，首先我们创建了一个 eventfd 文件描述符 `m_wakeup_fd`，然后向其写入一个值，并且再次读取该值。
}


timer.cc 
void Timer::resetArriveTime()
当涉及到操作时间、定时器或者其他需要精确计时的场景时，`timespec` 和 `itimerspec` 这两个结构体很有用。

1. **timespec**：
   - `timespec` 结构体用于表示时间。它包含了两个字段：秒数 (`tv_sec`) 和纳秒数 (`tv_nsec`)。
   - 通常用于表示相对或绝对时间，例如，在等待某个时间段后执行某个操作，或者获取当前时间的精确值。
   - 在许多系统编程中，如 POSIX 系统调用、多线程编程、网络编程等场景下，`timespec` 用于表示时间。

2. **itimerspec**：
   - `itimerspec` 结构体用于设置 POSIX 定时器的初始值和间隔值。
   - POSIX 定时器允许你在指定的时间间隔内执行特定的操作，比如周期性地触发某个事件或者定时执行某些任务。
   - `itimerspec` 结构体包含了两个 `timespec` 类型的字段：`it_interval`（定时器的间隔值）和 `it_value`（定时器的初始值）。
   - `it_value` 表示定时器的初始值，即第一次定时器触发的时间。`it_interval` 表示定时器的间隔值，即定时器下一次触发的时间相对于上一次触发的时间间隔。

这两个结构体在系统编程中常用于时间相关的操作，如定时任务、等待超时、事件触发等。通过它们，可以更精确地控制和管理时间，实现各种复杂的时间相关功能。